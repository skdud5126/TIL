# Kotlin - 객체와 클래스

### 객체

- 서로 연관된 것을 묶어 만든 **속성**과 **동작**이 있는 집합체

### 객체지향 프로그래밍의 4가지 특징

`추상화` - 공통성과 본질을 모아 추출

`상속` - 기존의 클래스를 재활용

`다형성` - 여러 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질

`캡슐화` - 서로 연관있는 것들을 묶어서 외부로부터 보호

---

### 클래스 기본

#### 함수 vs 메서드

```Kotlin

val car = Car("Red")
val car2 = Car("Yellow")
println("Color of the car : ${car.color}")

// Color of the car : Red

class Car(val color : String)
```

```Kotlin
val car = Car("Red","Volvo", 13)
// Color : Red Name : Volvo Age : 13

val car2 = Car("Blue","Tesla")  // 보조 constructor 사용예시
// Color : Blue Name : Tesla Age : 12
// Secondary constructor is called!

class Car(val color : String, val name : String, val age : Int) {
    init {
        // 객체가 생성될 때 실행되는 것
        println("Color : $color Name : $name Age : $age")
    }
}
    // 주생성자 보완완
    constructor(color : String, name : Stirng) : this(color,name, 12) {
        println("Secondary constructor is called!)
    }
```

---


### 클래스 상속

- `상속`은 클래스 간의 관게를 정의하고 부모 클래스의 특성을 자식 클래스에서 사용할 수 있도록 하거나, 클래스들의 공통점을 찾아 낼 때 유용하게 사용. 

- 상속은 객체 지향 프로그래밍의 중요한 개념 중 하나이며, 코드의 재사용성과 유연한 확장성을 높이는 데 기여.

#### 클래스 선언 안에서의 상속

- 코틀린에서 클래스 간의 상속은 클래스 선언 부분에서 : (콜론)을 사용하여 정의

- 부모 클래스와 자식 클래스 간의 상속 관계를 형성하려면 자식 클래스 선언부에서 부모 클래스를 명시

```Kotlin
// 부모 클래스
open class Animal(val name : String) {
    fun makeSound() {
        println("소리")
    }
}

// 자식 클래스
class Dog(name : String) : Animal(name) {
    fun bark() {
        println("왕왕!")
    }
}

```
- 위의 예제에서 Dog  클래스는 Animal 클래스를 상속받고 있습니다. [:] 뒤에 부모 클래스의 이름을 명시하여 `상속 관계`를 나타냄.

- 이렇게 하면 Dog 클래스는 Animal 클래스의 특성을 물려받아 사용할 수 있음.

#### open 키워드와 Method Overriding(메소드 오버라이딩)

- 코틀린에서는 상속을 허용하려면 부모 클래스에서 상속받을 메소드나 프로퍼티에 `open` 키워드 사용.

- 또한 자식 클래스에서 부모 클래스의 오버라이딩하려면 `override` 키워드 사용

- 쉽게 생각하면 override라는 것은 기존의 부모 클래스의 함수를 덮어 씌워준다 라고 생각


```Kotlin
open class Animal {
    open fun makeSound() {
        println("강아지 소리")
    }
}

class Dog : Animal {
    // 부모의 makeSound 함수도 실행하고 싶을떄 super 사용
    override fun makeSound() {
        super.makeSound()  // 부모 함수 먼저 실행되고 자식 함수 실행
        println("멍멍!")
    }
}

```